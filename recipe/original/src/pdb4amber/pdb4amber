#!/usr/bin/env python

import os
import sys
import math
import subprocess
from itertools import chain
import argparse
import parmed
try:
    from io import StringIO
except ImportError:
    from io import StringIO

import logging

logger = logging.getLogger('pdb4amber_log')
logger.setLevel(logging.DEBUG)

PY3 = sys.version_info[0] == 3
if PY3:
    string_types = str
else:
    string_types = str

__version__ = '1.6.dev'

#===========================================================================
#  Global residue variables, from residue.py file

__all__ = [
    'RESPROT', 'RESPROTE', 'RESNA', 'RESSOLV', 'RESSUGAR', 'AMBER_SUPPORTED_RESNAMES'
]

#
HEAVY_ATOM_DICT = {
    'ALA': 5,
    'ARG': 11,
    'ASN': 8,
    'ASP': 8,
    'CYS': 6,
    'GLN': 9,
    'GLU': 9,
    'GLY': 4,
    'HIS': 10,
    'ILE': 8,
    'LEU': 8,
    'LYS': 9,
    'MET': 8,
    'PHE': 11,
    'PRO': 7,
    'SER': 6,
    'THR': 7,
    'TRP': 14,
    'TYR': 12,
    'VAL': 7,
    'HID': 10,
    'HIE': 10,
    'HIN': 10,
    'HIP': 10,
    'CYX': 6,
    'ASH': 8,
    'GLH': 9,
    'LYH': 9
}

# Global constants
RESPROT = ('ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS',
           'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRP',
           'TYR', 'VAL', 'HID', 'HIE', 'HIN', 'HIP', 'CYX', 'ASH', 'GLH',
           'LYH', 'ACE', 'NME', 'GL4', 'AS4')

RESNA = ('C', 'G', 'U', 'A', 'DC', 'DG', 'DT', 'DA', 'OHE', 'C5', 'G5', 'U5',
         'A5', 'C3', 'G3', 'U3', 'A3', 'DC5', 'DG5', 'DT5', 'DA5', 'DC3',
         'DG3', 'DT3', 'DA3', 'PSU', 'OMU', '1MA' )

RESSOLV = ('WAT', 'HOH', 'AG', 'AL', 'Ag', 'BA', 'BR', 'Be', 'CA', 'CD', 'CE',
           'CL', 'CO', 'CR', 'CS', 'CU', 'CU1', 'Ce', 'Cl-', 'Cr', 'Dy', 'EU',
           'EU3', 'Er', 'F', 'FE', 'FE2', 'GD3', 'HE+', 'HG', 'HZ+', 'Hf',
           'IN', 'IOD', 'K', 'K+', 'LA', 'LI', 'LU', 'MG', 'MN', 'NA', 'NH4',
           'NI', 'Na+', 'Nd', 'PB', 'PD', 'PR', 'PT', 'Pu', 'RB', 'Ra', 'SM',
           'SR', 'Sm', 'Sn', 'TB', 'TL', 'Th', 'Tl', 'Tm', 'U4+', 'V2+', 'Y',
           'YB2', 'ZN', 'Zr')

#  Following not used right now; probably needs an flag to indicate that
#    we expect sugar residues in the input pdb file.)

RESSUGAR = (
    '0AA', '0AB', '0AD', '0AU', '0BA', '0BB', '0BC', '0BD', '0BU', '0CA',
    '0CB', '0CD', '0CU', '0DA', '0DB', '0DD', '0DU', '0EA', '0EB', '0FA',
    '0FB', '0GA', '0GB', '0GL', '0HA', '0HB', '0JA', '0JB', '0JD', '0JU',
    '0KA', '0KB', '0LA', '0LB', '0MA', '0MB', '0NA', '0NB', '0OA', '0OB',
    '0PA', '0PB', '0PD', '0PU', '0QA', '0QB', '0RA', '0RB', '0RD', '0RU',
    '0SA', '0SB', '0TA', '0TB', '0TV', '0Tv', '0UA', '0UB', '0VA', '0VB',
    '0WA', '0WB', '0XA', '0XB', '0XD', '0XU', '0YA', '0YB', '0ZA', '0ZB',
    '0aA', '0aB', '0aD', '0aU', '0bA', '0bB', '0bC', '0bD', '0bU', '0cA',
    '0cB', '0cD', '0cU', '0dA', '0dB', '0dD', '0dU', '0eA', '0eB', '0fA',
    '0fB', '0gA', '0gB', '0gL', '0hA', '0hB', '0jA', '0jB', '0jD', '0jU',
    '0kA', '0kB', '0lA', '0lB', '0mA', '0mB', '0nA', '0nB', '0oA', '0oB',
    '0pA', '0pB', '0pD', '0pU', '0qA', '0qB', '0rA', '0rB', '0rD', '0rU',
    '0sA', '0sB', '0tA', '0tB', '0tV', '0tv', '0uA', '0uB', '0vA', '0vB',
    '0wA', '0wB', '0xA', '0xB', '0xD', '0xU', '0yA', '0yB', '0zA', '0zB',
    '1AA', '1AB', '1AD', '1AU', '1BA', '1BB', '1BD', '1BU', '1CA', '1CB',
    '1CD', '1CU', '1DA', '1DB', '1DD', '1DU', '1EA', '1EB', '1FA', '1FB',
    '1GA', '1GB', '1HA', '1HB', '1JA', '1JB', '1JD', '1JU', '1KA', '1KB',
    '1LA', '1LB', '1MA', '1MB', '1NA', '1NB', '1OA', '1OB', '1PA', '1PB',
    '1PD', '1PU', '1QA', '1QB', '1RA', '1RB', '1RD', '1RU', '1TA', '1TB',
    '1TV', '1Tv', '1UA', '1UB', '1VA', '1VB', '1WA', '1WB', '1XA', '1XB',
    '1XD', '1XU', '1YA', '1YB', '1ZA', '1ZB', '1aA', '1aB', '1aD', '1aU',
    '1bA', '1bB', '1bD', '1bU', '1cA', '1cB', '1cD', '1cU', '1dA', '1dB',
    '1dD', '1dU', '1eA', '1eB', '1fA', '1fB', '1gA', '1gB', '1hA', '1hB',
    '1jA', '1jB', '1jD', '1jU', '1kA', '1kB', '1lA', '1lB', '1mA', '1mB',
    '1nA', '1nB', '1oA', '1oB', '1pA', '1pB', '1pD', '1pU', '1qA', '1qB',
    '1rA', '1rB', '1rD', '1rU', '1tA', '1tB', '1tV', '1tv', '1uA', '1uB',
    '1vA', '1vB', '1wA', '1wB', '1xA', '1xB', '1xD', '1xU', '1yA', '1yB',
    '1zA', '1zB', '2AA', '2AB', '2AD', '2AU', '2BA', '2BB', '2BD', '2BU',
    '2CA', '2CB', '2CD', '2CU', '2DA', '2DB', '2DD', '2DU', '2EA', '2EB',
    '2FA', '2FB', '2GA', '2GB', '2HA', '2HB', '2JA', '2JB', '2JD', '2JU',
    '2KA', '2KB', '2LA', '2LB', '2MA', '2MB', '2NA', '2NB', '2OA', '2OB',
    '2PA', '2PB', '2PD', '2PU', '2QA', '2QB', '2RA', '2RB', '2RD', '2RU',
    '2TA', '2TB', '2TV', '2Tv', '2UA', '2UB', '2XA', '2XB', '2XD', '2XU',
    '2ZA', '2ZB', '2aA', '2aB', '2aD', '2aU', '2bA', '2bB', '2bD', '2bU',
    '2cA', '2cB', '2cD', '2cU', '2dA', '2dB', '2dD', '2dU', '2eA', '2eB',
    '2fA', '2fB', '2gA', '2gB', '2hA', '2hB', '2jA', '2jB', '2jD', '2jU',
    '2kA', '2kB', '2lA', '2lB', '2mA', '2mB', '2nA', '2nB', '2oA', '2oB',
    '2pA', '2pB', '2pD', '2pU', '2qA', '2qB', '2rA', '2rB', '2rD', '2rU',
    '2tA', '2tB', '2tV', '2tv', '2uA', '2uB', '2xA', '2xB', '2xD', '2xU',
    '2zA', '2zB', '3AA', '3AB', '3AD', '3AU', '3BA', '3BB', '3BC', '3BD',
    '3BU', '3CA', '3CB', '3CD', '3CU', '3DA', '3DB', '3DD', '3DU', '3EA',
    '3EB', '3FA', '3FB', '3GA', '3GB', '3HA', '3HB', '3JA', '3JB', '3JD',
    '3JU', '3KA', '3KB', '3LA', '3LB', '3MA', '3MB', '3NA', '3NB', '3OA',
    '3OB', '3PA', '3PB', '3PD', '3PU', '3QA', '3QB', '3RA', '3RB', '3RD',
    '3RU', '3TA', '3TB', '3UA', '3UB', '3VA', '3VB', '3WA', '3WB', '3XA',
    '3XB', '3XD', '3XU', '3YA', '3YB', '3ZA', '3ZB', '3aA', '3aB', '3aD',
    '3aU', '3bA', '3bB', '3bC', '3bD', '3bU', '3cA', '3cB', '3cD', '3cU',
    '3dA', '3dB', '3dD', '3dU', '3eA', '3eB', '3fA', '3fB', '3gA', '3gB',
    '3hA', '3hB', '3jA', '3jB', '3jD', '3jU', '3kA', '3kB', '3lA', '3lB',
    '3mA', '3mB', '3nA', '3nB', '3oA', '3oB', '3pA', '3pB', '3pD', '3pU',
    '3qA', '3qB', '3rA', '3rB', '3rD', '3rU', '3tA', '3tB', '3uA', '3uB',
    '3vA', '3vB', '3wA', '3wB', '3xA', '3xB', '3xD', '3xU', '3yA', '3yB',
    '3zA', '3zB', '4AA', '4AB', '4BA', '4BB', '4BD', '4BU', '4CA', '4CB',
    '4CD', '4CU', '4DA', '4DB', '4EA', '4EB', '4FA', '4FB', '4GA', '4GB',
    '4GL', '4HA', '4HB', '4JA', '4JB', '4JD', '4JU', '4KA', '4KB', '4LA',
    '4LB', '4MA', '4MB', '4NA', '4NB', '4OA', '4OB', '4PA', '4PB', '4PD',
    '4PU', '4QA', '4QB', '4RA', '4RB', '4SA', '4SB', '4TA', '4TB', '4TV',
    '4Tv', '4UA', '4UB', '4VA', '4VB', '4WA', '4WB', '4XA', '4XB', '4YA',
    '4YB', '4ZA', '4ZB', '4aA', '4aB', '4bA', '4bB', '4bD', '4bU', '4cA',
    '4cB', '4cD', '4cU', '4dA', '4dB', '4eA', '4eB', '4fA', '4fB', '4gA',
    '4gB', '4gL', '4hA', '4hB', '4jA', '4jB', '4jD', '4jU', '4kA', '4kB',
    '4lA', '4lB', '4mA', '4mB', '4nA', '4nB', '4oA', '4oB', '4pA', '4pB',
    '4pD', '4pU', '4qA', '4qB', '4rA', '4rB', '4sA', '4sB', '4tA', '4tB',
    '4tV', '4tv', '4uA', '4uB', '4vA', '4vB', '4wA', '4wB', '4xA', '4xB',
    '4yA', '4yB', '4zA', '4zB', '5AD', '5AU', '5BA', '5BB', '5CA', '5CB',
    '5DD', '5DU', '5JA', '5JB', '5PA', '5PB', '5RD', '5RU', '5XD', '5XU',
    '5aD', '5aU', '5bA', '5bB', '5cA', '5cB', '5dD', '5dU', '5jA', '5jB',
    '5pA', '5pB', '5rD', '5rU', '5xD', '5xU', '6BD', '6BU', '6CD', '6CU',
    '6EA', '6EB', '6GA', '6GB', '6JD', '6JU', '6KA', '6KB', '6LA', '6LB',
    '6MA', '6MB', '6NA', '6NB', '6PD', '6PU', '6TA', '6TB', '6VA', '6VB',
    '6WA', '6WB', '6YA', '6YB', '6bD', '6bU', '6cD', '6cU', '6eA', '6eB',
    '6gA', '6gB', '6jD', '6jU', '6kA', '6kB', '6lA', '6lB', '6mA', '6mB',
    '6nA', '6nB', '6pD', '6pU', '6tA', '6tB', '6vA', '6vB', '6wA', '6wB',
    '6yA', '6yB', '7GL', '7SA', '7SB', '7gL', '7sA', '7sB', '8GL', '8SA',
    '8SB', '8gL', '8sA', '8sB', '9GL', '9SA', '9SB', '9gL', '9sA', '9sB',
    'ACX', 'AGL', 'ASA', 'ASB', 'AgL', 'AsA', 'AsB', 'BGL', 'BSA', 'BSB',
    'BgL', 'BsA', 'BsB', 'CA2', 'CGL', 'CSA', 'CSB', 'CgL', 'CsA', 'CsB',
    'DGL', 'DSA', 'DSB', 'DgL', 'DsA', 'DsB', 'EGL', 'ESA', 'ESB', 'EgL',
    'EsA', 'EsB', 'FGL', 'FSA', 'FSB', 'FgL', 'FsA', 'FsB', 'GGL', 'GSA',
    'GSB', 'GgL', 'GsA', 'GsB', 'HGL', 'HSA', 'HSB', 'HgL', 'HsA', 'HsB',
    'IGL', 'ISA', 'ISB', 'IgL', 'IsA', 'IsB', 'JGL', 'JSA', 'JSB', 'JgL',
    'JsA', 'JsB', 'KGL', 'KSA', 'KSB', 'KgL', 'KsA', 'KsB', 'MEX', 'NLN',
    'OLS', 'OLT', 'OME', 'PEA', 'PEB', 'PGA', 'PGB', 'PKA', 'PKB', 'PLA',
    'PLB', 'PMA', 'PMB', 'PNA', 'PNB', 'PTA', 'PTB', 'PeA', 'PeB', 'PgA',
    'PgB', 'PkA', 'PkB', 'PlA', 'PlB', 'PmA', 'PmB', 'PnA', 'PnB', 'PtA',
    'PtB', 'QBD', 'QBU', 'QCD', 'QCU', 'QEA', 'QEB', 'QGA', 'QGB', 'QJD',
    'QJU', 'QKA', 'QKB', 'QLA', 'QLB', 'QMA', 'QMB', 'QNA', 'QNB', 'QPD',
    'QPU', 'QTA', 'QTB', 'QVA', 'QVB', 'QWA', 'QWB', 'QYA', 'QYB', 'QbD',
    'QbU', 'QcD', 'QcU', 'QeA', 'QeB', 'QgA', 'QgB', 'QjD', 'QjU', 'QkA',
    'QkB', 'QlA', 'QlB', 'QmA', 'QmB', 'QnA', 'QnB', 'QpD', 'QpU', 'QtA',
    'QtB', 'QvA', 'QvB', 'QwA', 'QwB', 'QyA', 'QyB', 'REA', 'REB', 'RGA',
    'RGB', 'RKA', 'RKB', 'RLA', 'RLB', 'RMA', 'RMB', 'RNA', 'RNB', 'ROH',
    'RTA', 'RTB', 'ReA', 'ReB', 'RgA', 'RgB', 'RkA', 'RkB', 'RlA', 'RlB',
    'RmA', 'RmB', 'RnA', 'RnB', 'RtA', 'RtB', 'SEA', 'SEB', 'SGA', 'SGB',
    'SKA', 'SKB', 'SLA', 'SLB', 'SMA', 'SMB', 'SNA', 'SNB', 'STA', 'STB',
    'SO3', 'SeA', 'SeB', 'SgA', 'SgB', 'SkA', 'SkB', 'SlA', 'SlB', 'SmA',
    'SmB', 'SnA', 'SnB', 'StA', 'StB', 'TAA', 'TAB', 'TBT', 'TDA', 'TDB',
    'TEA', 'TEB', 'TFA', 'TFB', 'TGA', 'TGB', 'THA', 'THB', 'TKA', 'TKB',
    'TLA', 'TLB', 'TMA', 'TMB', 'TNA', 'TNB', 'TOA', 'TOB', 'TQA', 'TQB',
    'TRA', 'TRB', 'TTA', 'TTB', 'TUA', 'TUB', 'TXA', 'TXB', 'TZA', 'TZB',
    'TaA', 'TaB', 'TdA', 'TdB', 'TeA', 'TeB', 'TfA', 'TfB', 'TgA', 'TgB',
    'ThA', 'ThB', 'TkA', 'TkB', 'TlA', 'TlB', 'TmA', 'TmB', 'TnA', 'TnB',
    'ToA', 'ToB', 'TqA', 'TqB', 'TrA', 'TrB', 'TtA', 'TtB', 'TuA', 'TuB',
    'TxA', 'TxB', 'TzA', 'TzB', 'UBD', 'UBU', 'UCD', 'UCU', 'UEA', 'UEB',
    'UGA', 'UGB', 'UJD', 'UJU', 'UKA', 'UKB', 'ULA', 'ULB', 'UMA', 'UMB',
    'UNA', 'UNB', 'UPD', 'UPU', 'UTA', 'UTB', 'UVA', 'UVB', 'UWA', 'UWB',
    'UYA', 'UYB', 'UbD', 'UbU', 'UcD', 'UcU', 'UeA', 'UeB', 'UgA', 'UgB',
    'UjD', 'UjU', 'UkA', 'UkB', 'UlA', 'UlB', 'UmA', 'UmB', 'UnA', 'UnB',
    'UpD', 'UpU', 'UtA', 'UtB', 'UvA', 'UvB', 'UwA', 'UwB', 'UyA', 'UyB',
    'VBD', 'VBU', 'VCD', 'VCU', 'VEA', 'VEB', 'VGA', 'VGB', 'VJD', 'VJU',
    'VKA', 'VKB', 'VLA', 'VLB', 'VMA', 'VMB', 'VNA', 'VNB', 'VPD', 'VPU',
    'VTA', 'VTB', 'VVA', 'VVB', 'VWA', 'VWB', 'VYA', 'VYB', 'VbD', 'VbU',
    'VcD', 'VcU', 'VeA', 'VeB', 'VgA', 'VgB', 'VjD', 'VjU', 'VkA', 'VkB',
    'VlA', 'VlB', 'VmA', 'VmB', 'VnA', 'VnB', 'VpD', 'VpU', 'VtA', 'VtB',
    'VvA', 'VvB', 'VwA', 'VwB', 'VyA', 'VyB', 'WAA', 'WAB', 'WBA', 'WBB',
    'WBD', 'WBU', 'WCA', 'WCB', 'WCD', 'WCU', 'WDA', 'WDB', 'WEA', 'WEB',
    'WFA', 'WFB', 'WGA', 'WGB', 'WHA', 'WHB', 'WJA', 'WJB', 'WJD', 'WJU',
    'WKA', 'WKB', 'WLA', 'WLB', 'WMA', 'WMB', 'WNA', 'WNB', 'WOA', 'WOB',
    'WPA', 'WPB', 'WPD', 'WPU', 'WQA', 'WQB', 'WRA', 'WRB', 'WTA', 'WTB',
    'WUA', 'WUB', 'WVA', 'WVB', 'WWA', 'WWB', 'WXA', 'WXB', 'WYA', 'WYB',
    'WZA', 'WZB', 'WaA', 'WaB', 'WbA', 'WbB', 'WbD', 'WbU', 'WcA', 'WcB',
    'WcD', 'WcU', 'WdA', 'WdB', 'WeA', 'WeB', 'WfA', 'WfB', 'WgA', 'WgB',
    'WhA', 'WhB', 'WjA', 'WjB', 'WjD', 'WjU', 'WkA', 'WkB', 'WlA', 'WlB',
    'WmA', 'WmB', 'WnA', 'WnB', 'WoA', 'WoB', 'WpA', 'WpB', 'WpD', 'WpU',
    'WqA', 'WqB', 'WrA', 'WrB', 'WtA', 'WtB', 'WuA', 'WuB', 'WvA', 'WvB',
    'WwA', 'WwB', 'WxA', 'WxB', 'WyA', 'WyB', 'WzA', 'WzB', 'XEA', 'XEB',
    'XGA', 'XGB', 'XKA', 'XKB', 'XLA', 'XLB', 'XMA', 'XMB', 'XNA', 'XNB',
    'XTA', 'XTB', 'XeA', 'XeB', 'XgA', 'XgB', 'XkA', 'XkB', 'XlA', 'XlB',
    'XmA', 'XmB', 'XnA', 'XnB', 'XtA', 'XtB', 'YAA', 'YAB', 'YDA', 'YDB',
    'YEA', 'YEB', 'YFA', 'YFB', 'YGA', 'YGB', 'YHA', 'YHB', 'YKA', 'YKB',
    'YLA', 'YLB', 'YMA', 'YMB', 'YNA', 'YNB', 'YOA', 'YOB', 'YQA', 'YQB',
    'YRA', 'YRB', 'YTA', 'YTB', 'YTV', 'YTv', 'YUA', 'YUB', 'YXA', 'YXB',
    'YZA', 'YZB', 'YaA', 'YaB', 'YdA', 'YdB', 'YeA', 'YeB', 'YfA', 'YfB',
    'YgA', 'YgB', 'YhA', 'YhB', 'YkA', 'YkB', 'YlA', 'YlB', 'YmA', 'YmB',
    'YnA', 'YnB', 'YoA', 'YoB', 'YqA', 'YqB', 'YrA', 'YrB', 'YtA', 'YtB',
    'YtV', 'Ytv', 'YuA', 'YuB', 'YxA', 'YxB', 'YzA', 'YzB', 'ZAA', 'ZAB',
    'ZAD', 'ZAU', 'ZDA', 'ZDB', 'ZDD', 'ZDU', 'ZEA', 'ZEB', 'ZFA', 'ZFB',
    'ZGA', 'ZGB', 'ZHA', 'ZHB', 'ZKA', 'ZKB', 'ZLA', 'ZLB', 'ZMA', 'ZMB',
    'ZNA', 'ZNB', 'ZOA', 'ZOB', 'ZOLS', 'ZOLT', 'ZQA', 'ZQB', 'ZRA', 'ZRB',
    'ZRD', 'ZRU', 'ZTA', 'ZTB', 'ZUA', 'ZUB', 'ZXA', 'ZXB', 'ZXD', 'ZXU',
    'ZZA', 'ZZB', 'ZaA', 'ZaB', 'ZaD', 'ZaU', 'ZdA', 'ZdB', 'ZdD', 'ZdU',
    'ZeA', 'ZeB', 'ZfA', 'ZfB', 'ZgA', 'ZgB', 'ZhA', 'ZhB', 'ZkA', 'ZkB',
    'ZlA', 'ZlB', 'ZmA', 'ZmB', 'ZnA', 'ZnB', 'ZoA', 'ZoB', 'ZqA', 'ZqB',
    'ZrA', 'ZrB', 'ZrD', 'ZrU', 'ZtA', 'ZtB', 'ZuA', 'ZuB', 'ZxA', 'ZxB',
    'ZxD', 'ZxU', 'ZzA', 'ZzB', '0AE', '2AE', '4AE', 'YGa', '0AF', '2AF',
    '4AF', 'YAF', '0dR', '3dR', '4dR', 'WdR')

AMBER_SUPPORTED_RESNAMES = set(RESPROT + RESNA + RESSOLV + RESSUGAR)
# AMBER_SUPPORTED_RESNAMES = set(RESPROT + RESNA + RESSOLV)

#  For correct protein gap detection, we need to extend the RESPROT set:
#  RESPROT itself give residue names that are included in
#  leaprc.protein.xxxx.  To this, we need to add other residues that
#  might be in the amber_library, such as MSE.  Not yet sure how to do
#  this in general...

RESPROTE = ('ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS',
           'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRP',
           'TYR', 'VAL', 'HID', 'HIE', 'HIN', 'HIP', 'CYX', 'ASH', 'GLH',
           'LYH', 'ACE', 'NME', 'GL4', 'AS4', 'MSE')
#===========================================================================


class AmberPDBFixer(object):
    ''' Base class (?) for handling pdb4amber (try to mimic
    original code)

    Parameters
    ----------
    parm : str or parmed.Structure or None, default None
    '''

    def __init__(self, parm=None):
        # TODO: make a copy?
        # Why not now? parm[:] will not correctly assign TER residue
        # self.parm = parm[:]
        if isinstance(parm, string_types):
            self.parm = parmed.load_file(parm)
        elif parm is None:
            self.parm = parmed.Structure()
        else:
            self.parm = parm

    def mutate(self, mask_list):
        # TODO : same syntax as pdbfixer (openmm)?
        '''

        Parameters
        ----------
        mask_list: List[Tuple[int, str]]
            [(1, 'ARG'),]

        Notes
        -----
        Should also use `add_hydrogen` and `add_missing_atoms`
        '''
        idxs = []
        for (idx, resname) in mask_list:
            self.parm.residues[idx].name = resname
            idxs.append(str(idx + 1))
        excluded_mask = ':' + ','.join(idxs) + '&!@C,CA,N,O'
        self.parm.strip(excluded_mask)
        return self

    def pack(self, mol, n_copies, ig=8888, grid_spacing=0.2):
        ''' add n_copies of mol to AmberPDBFixer

        Parameters
        ----------
        mol : parmed.Structure
        n_copies : number of `mol`
        ig : int
            randome seed
        grid_spacing : float

        Requires
        --------
        AddToBox program
        '''
        add_to_box_exe = amberbin('AddToBox') or 'AddToBox'
        input_pdb = 'input.pdb'
        mol_pdb = 'mol.pdb'
        out_pdb = 'out.pdb'

        with tempfolder():
            mol.save(mol_pdb, overwrite=True)
            self.parm.save(input_pdb, overwrite=True)
            command = [
                add_to_box_exe, '-c', input_pdb, '-a', mol_pdb, '-na',
                str(n_copies), '-IG', str(ig), '-G', str(grid_spacing), '-o',
                out_pdb
            ]
            easy_call(command)
            self.parm = parmed.load_file(out_pdb)
        return self

    def assign_histidine(self):
        ''' Assign correct name for Histidine based on the atom name

        Returns
        -------
        parm : updated `parm`
        '''

        for residue in self.parm.residues:
            if residue.name == 'HIS':
                atom_name_set = sorted(
                    set(atom.name for atom in residue.atoms
                        if atom.atomic_number == 1))
                if set(['HD1', 'HE2']).issubset(atom_name_set):
                    residue.name = 'HIP'
                elif 'HD1' in atom_name_set:
                    residue.name = 'HID'
                elif 'HE2' in atom_name_set:
                    residue.name = 'HIE'
                else:
                    residue.name = 'HIS'
        return self

    def strip(self, mask):
        self.parm.strip(mask)
        return self

    def find_missing_heavy_atoms(self, heavy_atom_dict=HEAVY_ATOM_DICT):
        residue_collection = []
        for residue in self.parm.residues:
            if residue.name in heavy_atom_dict:
                n_heavy_atoms = len(
                    set(atom.name for atom in residue.atoms
                        if atom.atomic_number != 1))
                n_missing = heavy_atom_dict[residue.name] - n_heavy_atoms
                if n_missing > 0:
                    residue_collection.append([residue, n_missing])
        return residue_collection

    def add_missing_atoms(self):
        in_pdb = 'in.pdb'
        out_pdb = 'out.pdb'
        with tempfolder():
            self.write_pdb(in_pdb)
            with open('leap.in', 'w') as fh:
                fh.write('source leaprc.protein.ff14SB\n')
                fh.write('source leaprc.DNA.bsc1\n')
                fh.write('source leaprc.RNA.OL3\n')
                fh.write('x = loadpdb {}\n'.format(in_pdb))
                fh.write('savepdb x {}\n'.format(out_pdb))
                fh.write('quit')
            easy_call('tleap -f leap.in', shell=True)
            self.parm = parmed.load_file(out_pdb)
        return self

    def constph(self):
        """ Update AS4, GL4, HIP for constph.

        Returns
        -------
        parm : updated `parm`
        """
        for residue in self.parm.residues:
            if residue.name == 'ASP':
                residue.name = 'AS4'
            elif residue.name == 'GLU':
                residue.name = 'GL4'
            elif residue.name == 'HIS':
                residue.name = 'HIP'
            else:
                pass
        return self

    def find_gaps(self):
        # report original resnum?
        CA_atoms = []
        C_atoms = []
        N_atoms = []
        O3_atoms = []
        O5_atoms = []
        gaplist = []
        parm = self.parm

        # First, for protein chains:
        for i, atom in enumerate(parm.atoms):
            if atom.name == 'CA' and atom.residue.name in RESPROTE:
                CA_atoms.append(i)
            if atom.name == 'C' and atom.residue.name in RESPROTE:
                C_atoms.append(i)
            if atom.name == 'N' and atom.residue.name in RESPROTE:
                N_atoms.append(i)

        nca = len(CA_atoms)
        ngaps = 0

        for i in range(nca - 1):
            is_ter = parm.atoms[CA_atoms[i]].residue.ter
            if is_ter:
                continue
            # Changed here to look at the C-N peptide bond distance:
            C_atom = parm.atoms[C_atoms[i]]
            N_atom = parm.atoms[N_atoms[i + 1]]

            dx = float(C_atom.xx) - float(N_atom.xx)
            dy = float(C_atom.xy) - float(N_atom.xy)
            dz = float(C_atom.xz) - float(N_atom.xz)
            gap = math.sqrt(dx * dx + dy * dy + dz * dz)

            if gap > 2.0:
                gaprecord = (gap, C_atom.residue.name, C_atom.residue.idx,
                             N_atom.residue.name, N_atom.residue.idx)
                gaplist.append(gaprecord)
                ngaps += 1

        # Repeat for nucleic acid chains:
        for i, atom in enumerate(parm.atoms):
            if atom.name == "O3'" and atom.residue.name in RESNA:
                O3_atoms.append(i)
                # print(i,atom.name,atom.residue.name,atom.residue.number,atom.residue.idx)
            if atom.name == "O5'" and atom.residue.name in RESNA:
                O5_atoms.append(i)
                # print(i,atom.name,atom.residue.name,atom.residue.number,atom.residue.idx)

        np = len(O5_atoms)

        for i in range(np - 1):
            is_ter = parm.atoms[O5_atoms[i]].residue.ter
            if is_ter:
                continue
            O3_atom = parm.atoms[O3_atoms[i]]
            O5_atom = parm.atoms[O5_atoms[i + 1]]

            dx = float(O3_atom.xx) - float(O5_atom.xx)
            dy = float(O3_atom.xy) - float(O5_atom.xy)
            dz = float(O3_atom.xz) - float(O5_atom.xz)
            gap = math.sqrt(dx * dx + dy * dy + dz * dz)

            if gap > 2.8:
                gaprecord = (gap, O3_atom.residue.name, O3_atom.residue.idx,
                             O5_atom.residue.name, O5_atom.residue.idx)
                gaplist.append(gaprecord)
                ngaps += 1

        if ngaps > 0:
            logger.info("\n---------- Gaps (Renumbered Residues!)")
            cformat = "gap of %lf A between %s %d and %s %d"
            for _, (d, resname0, resid0, resname1,
                    resid1) in enumerate(gaplist):
                # convert to 1-based
                logger.info(cformat % (d, resname0, resid0 + 1, resname1,
                                       resid1 + 1))
        return gaplist

    def find_disulfide(self):
        """ return set of cys-cys pairs

        Returns
        -------
        cys_cys_set : Set[List[int, int]]
        """
        residues = [
            res for res in self.parm.residues if res.name in ['CYS', 'CYX']
        ]

        cys_cys_resid_set = set()
        cys_cys_atomidx_set = set()
        for residue in residues:
            for atom in residue.atoms:
                if 'SG' in atom.name:
                    for partner in atom.bond_partners:
                        if (partner.residue.name.startswith('CY') and
                                partner.name.startswith('SG')):
                            # use tuple for hashing
                            cys_cys_resid_set.add(
                                tuple(
                                    sorted((atom.residue.idx,
                                            partner.residue.idx))))
                            cys_cys_atomidx_set.add(
                                tuple(sorted((atom.idx, partner.idx))))
        return sorted(cys_cys_resid_set), sorted(cys_cys_atomidx_set)

    def rename_cys_to_cyx(self, cys_cys_set):
        """ Rename CYS to CYX of having S-S bond.

        Parameters
        ----------
        cys_cys_set : Set[List[int, int]]
        """
        for index in chain.from_iterable(cys_cys_set):
            residue = self.parm.residues[index]
            residue.name = 'CYX'

    def find_non_standard_resnames(self):
        ns_names = set()
        for residue in self.parm.residues:
            if len(residue.name) > 3:
                rname = residue.name[:3]
            else:
                rname = residue.name
            if rname.strip() not in AMBER_SUPPORTED_RESNAMES:
                ns_names.add(rname)
        return ns_names

    def add_hydrogen(self, no_reduce_db=False):
        ''' Use reduce program to add hydrogen

        Parameters
        ----------
        obj: file object or parmed.Structure or its derived class

        Returns
        -------
        parm : parmed.Structure

        Requires
        --------
        reduce
        '''

        def touch(fname, times=None):
            with open(fname, 'a'):
                os.utime(fname, times)

        parameters = '-BUILD -NUC -NOFLIP'
        if no_reduce_db:
          touch('./dummydb')
          parameters += ' -DB ./dummydb'
        parameters += ' -'

        fileobj = StringIO()
        self.write_pdb(fileobj)
        fileobj.seek(0)

        reduce_out = run_reduce_with_timeout(
          parameters = parameters,
          stdin_lines = fileobj.read(),
          stdout_splitlines = False,
          )
        assert reduce_out.return_code==0

        pdbh = StringIO()
        pdbh.write(reduce_out.stdout_buffer)
        pdbh.seek(0)
        self.parm = parmed.read_PDB(pdbh)
        return self

    def old(self, no_reduce_db):
        try:
            if no_reduce_db:
                touch('./dummydb')
            fileobj = StringIO()
            self.write_pdb(fileobj)
            fileobj.seek(0)
            reduce = os.path.join(os.getenv('LIBTBX_BUILD'),
                 'reduce', 'exe', 'reduce')
            if not os.path.exists(reduce):
                reduce = 'phenix.reduce'
            cmd = [
                        reduce, '-BUILD', '-NUC', '-NOFLIP', '-DB ./dummydb',
                        '-'
                    ]
            if no_reduce_db:
                process = subprocess.Popen(
                    [
                        reduce, '-BUILD', '-NUC', '-NOFLIP', '-DB ./dummydb',
                        '-'
                    ],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
            else:
                process = subprocess.Popen(
                    [reduce, '-BUILD', '-NUC', '-NOFLIP', '-'],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
            out, err = process.communicate(str.encode(fileobj.read()))
            out = out.decode()
            err = err.decode()
            if process.wait():
                logger.error("REDUCE returned non-zero exit status: "
                             "See reduce_info.log for more details")
            # print out the reduce log even if it worked
            with open('reduce_info.log', 'w') as fh:
                fh.write(err)
            pdbh = StringIO(out)
            # not using load_file since it does not read StringIO
            print(('-'*80))
            print(pdbh)
            print(('-'*80))
            self.parm = parmed.read_PDB(pdbh)
        finally:
            fileobj.close()
            if no_reduce_db:
                os.unlink('./dummydb')
        return self

    def visualize(self):
        return self.parm.visualize()

    def write_pdb(self, filename):
        '''

        Parameters
        ----------
        filename : str or file object
        '''
        self.parm.write_pdb(filename)

    def _write_renum(self, basename):
        ''' write original and renumbered residue index
        '''

        with open(basename + '_renum.txt', 'w') as fh:
            for residue in self.parm.residues:
                fh.write("%3s %1s %5s    %3s %5s\n" %
                         (residue.name, residue.chain, residue.number, residue.name,
                          residue.idx + 1))

    def _write_pdb_to_stringio(self,
                               cys_cys_atomidx_set=None,
                               disulfide_conect=True,
                               noter=False,
                               **kwargs):
        stringio_file = StringIO()
        stringio_file_out = StringIO()
        self.parm.write_pdb(stringio_file, **kwargs)
        stringio_file.seek(0)
        lines = stringio_file.readlines()

        # TODO: update ParmEd?
        if disulfide_conect:
            conect_record = [
                'CONECT%5d%5d\n' % (idx0 + 1, idx1 + 1)
                for (idx0, idx1) in cys_cys_atomidx_set
            ]
            conect_str = ''.join(conect_record)
            lines[-1] = conect_str + 'END\n'

        if noter:
            lines = [line for line in lines if not line.startswith("TER")]

        stringio_file_out.writelines(lines)
        stringio_file_out.seek(0)
        return stringio_file_out

    def remove_water(self):
        ''' Remove waters and return new `parm` with only waters
        '''
        # TODO : add AMBER water names (TP3, ...)
        water_mask = ':' + ','.join(parmed.residue.WATER_NAMES)
        self.parm.strip(water_mask)
        return self

    def _summary(self):
        sumdict = dict(has_altlocs=False)

        alt_residues = set()
        chains = set()
        for residue in self.parm.residues:
            chains.add(residue.chain)
            for atom in residue.atoms:
                if atom.other_locations:
                    alt_residues.add(residue)

        # chain
        logger.info('\n----------Chains')
        logger.info('The following (original) chains have been found:')
        for chain_name in sorted(chains):
            logger.info(chain_name)

        # altlocs
        logger.info('\n---------- Alternate Locations (Original Residues!))')
        logger.info('\nThe following residues had alternate locations:')
        if alt_residues:
            sumdict['has_altlocs'] = True
            for residue in sorted(alt_residues):
                logger.info('{}_{}'.format(residue.name, residue.number))
        else:
            logger.info('None')
        return sumdict


def run(
        arg_pdbout,
        arg_pdbin,
        arg_nohyd=False,
        arg_dry=False,
        arg_prot=False,
        arg_amber_compatible_residues=False,
        arg_strip_atom_mask=None,
        arg_mutate_string=None,
        arg_constph=False,
        arg_mostpop=False,
        arg_reduce=False,
        arg_no_reduce_db=False,
        arg_model=0,
        arg_add_missing_atoms=False,
        arg_elbow=False,
        arg_logfile='pdb4amber.log',
        arg_keep_altlocs=False,
        arg_leap_template=False,
        arg_conect=True,
        arg_noter=False, ):

    # always reset handlers to avoid duplication if run method is called more
    # than once
    logger.handlers = []
    if isinstance(arg_logfile, string_types):
        logfile_handler = logging.FileHandler(arg_logfile)
    elif hasattr(arg_logfile, 'write'):
        logfile_handler = logging.StreamHandler(arg_logfile)
    else:
        raise ValueError(
            "wrong arg_logfile: must be either string or file object")

    logger.addHandler(logfile_handler)
    name = arg_pdbin if not hasattr(arg_pdbin,
                                    '__name__') else arg_pdbin.__name__
    logger.info("\n==================================================")
    logger.info("Summary of pdb4amber for: %s" % name)
    logger.info("===================================================")

    if arg_pdbin == arg_pdbout:
        raise RuntimeError(
            "The input and output file names cannot be the same!\n")

    base_filename, extension = os.path.splitext(arg_pdbout)
    if arg_pdbin == 'stdin':
        if PY3:
            pdbin = StringIO(sys.stdin.read())
        else:
            pdbin = sys.stdin
    else:
        pdbin = arg_pdbin

    if isinstance(pdbin, parmed.Structure):
        parm = pdbin
    elif hasattr(pdbin, 'read'):
        # StringIO (e.g: read from pipe)
        # need to use read_PDB
        parm = parmed.read_PDB(pdbin)
    else:
        parm = parmed.read_PDB(pdbin)

    pdbfixer = AmberPDBFixer(parm)

    pdbfixer._write_renum(base_filename)

    if arg_reduce:
        pdbfixer.add_hydrogen(no_reduce_db=arg_no_reduce_db)

    sumdict = pdbfixer._summary()

    # remove hydrogens if option -y is used:==============================
    if arg_nohyd:
        pdbfixer.parm.strip('@/H')

    # find non-standard Amber residues:===================================
    #   TODO: why does the following call discard the return array of
    #         non-standard residue names?
    ns_names = pdbfixer.find_non_standard_resnames()
    logger.info("-----------Non-standard-resnames")
    logger.info(", ".join(ns_names))

    ns_mask = ':' + ','.join(ns_names)
    ns_mask_filename = base_filename + '_nonprot.pdb'
    if ns_mask != ':':
        pdbfixer.parm[ns_mask].save(ns_mask_filename, overwrite=True)
    else:
        with open(ns_mask_filename, 'w') as fh:
            fh.write("")

    # if arg_elbow:
    #     ns_names = find_non_standard_resnames_elbow(parm)

    # keep only protein:==================================================
    if arg_prot:
        pdbfixer.parm.strip('!:' + ','.join(RESPROT))
    if arg_amber_compatible_residues:
        pdbfixer.parm.strip('!:' + ','.join(AMBER_SUPPORTED_RESNAMES))

    # strip atoms with given mask    =====================================
    if arg_strip_atom_mask is not None:
        pdbfixer.parm.strip(arg_strip_atom_mask)

    # remove water if -d option used:=====================================
    if arg_dry:
        water_mask = ':' + ','.join(parmed.residue.WATER_NAMES)
        water_parm = pdbfixer.parm[water_mask]
        pdbfixer.remove_water()
        water_parm.save('{}_water.pdb'.format(base_filename), overwrite=True)
    # find histidines that might have to be changed:=====================
    if arg_constph:
        pdbfixer.constph()
    else:
        pdbfixer.assign_histidine()

    # find possible S-S in the final protein:=============================
    sslist, cys_cys_atomidx_set = pdbfixer.find_disulfide()
    pdbfixer.rename_cys_to_cyx(sslist)
    with open(base_filename + '_sslink', 'w') as fh:
        for (idx0, idx1) in sslist:
            fh.write('{} {}\n'.format(idx0 + 1, idx1 + 1))

    # find possible gaps:==================================================
    gaplist = pdbfixer.find_gaps()

    mask_str_list = []
    if arg_mutate_string is not None:
        # e.g: arg_mutate_str = "3-ALA,4-GLU"
        for mask_str in arg_mutate_string.replace(';', ',').split(','):
            index, resname = mask_str.split('-')
            mask_str_list.append([int(index.strip()) - 1, resname.strip()])
        pdbfixer.mutate(mask_str_list)

        # mutation will remove all hydrogens
        # add back if using reduce
        if arg_reduce:
            pdbfixer.add_hydrogen(no_reduce_db=arg_no_reduce_db)

    # count heavy atoms:==================================================
    missing_atom_residues = pdbfixer.find_missing_heavy_atoms()
    logger.info("\n---------- Mising heavy atom(s)\n")
    if missing_atom_residues:
        for (residue, n_missing) in missing_atom_residues:
            logger.warn('{}_{} misses {} heavy atom(s)'.format(
                residue.name, residue.idx + 1, n_missing))
    else:
        logger.info('None')

    if arg_add_missing_atoms:
        pdbfixer.add_missing_atoms()

    # =====================================================================
    # make final output to new PDB file
    # =====================================================================
    if arg_model >= 0:
        final_coordinates = pdbfixer.parm.get_coordinates()[arg_model]
        write_kwargs = dict(coordinates=final_coordinates)
    else:
        # keep all models
        write_kwargs = dict()
    write_kwargs['increase_tercount'] = False # so CONECT record can work properly
    if not arg_keep_altlocs:
        if sumdict['has_altlocs']:
            logger.info('The alternate coordinates have been discarded.')
            if arg_mostpop:
                logger.info(
                    'Only the highest occupancy for each atom was kept.')
                write_kwargs = dict(altlocs='occupancy')
            else:
                logger.info(
                    'Only the first occurrence for each atom was kept.')
                write_kwargs = dict(altlocs='first')
        # remove altlocs label
        for atom in pdbfixer.parm.atoms:
            atom.altloc = ''
            for oatom in list(atom.other_locations.values()):
                oatom.altloc = ''
    if arg_pdbout in ['stdout', 'stderr'] or arg_pdbout.endswith('.pdb'):
        output = pdbfixer._write_pdb_to_stringio(
            cys_cys_atomidx_set=cys_cys_atomidx_set,
            disulfide_conect=arg_conect,
            noter=arg_noter,
            **write_kwargs)
        output.seek(0)
        if arg_pdbout in ['stdout', 'stderr']:
            pdb_out_filename = 'stdout.pdb'
            print((output.read()))
        else:
            pdb_out_filename = arg_pdbout
            with open(arg_pdbout, 'w') as fh:
                fh.write(output.read())
    else:
        # mol2 does not accept altloc keyword
        pdb_out_filename = arg_pdbout
        pdbfixer.parm.save(pdb_out_filename, overwrite=True)

    if arg_leap_template:
        with open('leap.template.in', 'w') as fh:
            if arg_prot:
                final_ns_names = []
            else:
                final_ns_names = ns_names
            content = _make_leap_template(
                parm,
                final_ns_names,
                gaplist,
                sslist,
                input_pdb=pdb_out_filename,
                prmtop='prmtop',
                rst7='rst7')
            fh.write(content)
    return ns_names, gaplist, sslist


def main(argv=None):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input",
        nargs='?',
        help="PDB input file (default: stdin)", )
    parser.add_argument(
        "-i",
        "--in",
        metavar="FILE",
        dest="pdbin",
        help="PDB input file (default: stdin)",
        default='stdin')
    parser.add_argument(
        "-o",
        "--out",
        metavar="FILE",
        dest="pdbout",
        help="PDB output file (default: stdout)",
        default='stdout')
    parser.add_argument(
        "-y",
        "--nohyd",
        action="store_true",
        dest="nohyd",
        help="remove all hydrogen atoms (default: no)")
    parser.add_argument(
        "-d",
        "--dry",
        action="store_true",
        dest="dry",
        help="remove all water molecules (default: no)")
    parser.add_argument(
        "-s",
        "--strip",
        dest="strip_atom_mask",
        default=None,
        help="Strip given atom mask, (default: no)")
    parser.add_argument(
        "-m",
        "--mutate",
        dest="mutation_string",
        default=None,
        help="Mutate residue")
    parser.add_argument(
        "-p",
        "--prot",
        action="store_true",
        dest="prot",
        help="keep only protein residues (default: no)")
    parser.add_argument(
        "-a",
        "--amber-compatible-residues",
        action="store_true",
        dest="amber_compatible_residues",
        help="keep only Amber-compatible residues (default: no)")
    parser.add_argument(
        "--constantph",
        action="store_true",
        dest="constantph",
        help="rename GLU,ASP,HIS for constant pH simulation")
    parser.add_argument(
        "--most-populous",
        action="store_true",
        dest="mostpop",
        help="keep most populous alt. conf. (default is to keep 'A')")
    parser.add_argument(
        "--keep-altlocs",
        action="store_true",
        dest="keep_altlocs",
        help="Keep alternative conformations")
    parser.add_argument(
        "--reduce",
        action="store_true",
        dest="reduce",
        help="Run Reduce first to add hydrogens.  (default: no)")
    parser.add_argument(
        "--no-reduce-db",
        action="store_true",
        dest="no_reduce_db",
        help="If reduce is on, skip using it for hetatoms.  (default: usual reduce behavior for hetatoms)")
    parser.add_argument(
        "--pdbid",
        action="store_true",
        dest="pdbid",
        help="fetch structure with given pdbid, "
        "should combined with -i option.\n"
        "Subjected to change")
    parser.add_argument(
        "--add-missing-atoms",
        action="store_true",
        dest="add_missing_atoms",
        help="Use tleap to add missing atoms. (EXPERIMENTAL OPTION)")
    parser.add_argument(
        "--model",
        type=int,
        dest="model",
        default=1,
        help=
        "Model to use from a multi-model pdb file (integer).  (default: use 1st model). "
        "Use a negative number to keep all models")
    parser.add_argument(
        "-l",
        "--logfile",
        metavar="FILE",
        dest="logfile",
        help="log filename",
        default='stderr')
    parser.add_argument(
        "-v", "--version", action="store_true", dest="version", help="version")
    parser.add_argument(
        "--leap-template",
        action='store_true',
        dest="leap_template",
        help="write a leap template for easy adaption\n(EXPERIMENTAL)")
    parser.add_argument(
        "--no-conect",
        action='store_true',
        dest="no_conect",
        help="Not write S-S conect record")
    parser.add_argument(
        "--noter", action='store_true', dest="noter", help="Not writing TER")
    opt = parser.parse_args(argv)

    # pdbin : {str, file object, parmed.Structure}
    if opt.version:
        print(__version__)
    if opt.input is not None:
        pdbin = opt.input
    else:
        pdbin = opt.pdbin

    if opt.pdbid:
        pdbin = parmed.download_PDB(pdbin)

    if opt.pdbin == 'stdin' and opt.input is None:
        if os.isatty(sys.stdin.fileno()):
            parser.print_help()
            sys.exit(0)
    if opt.logfile == 'stderr':
        logfile = sys.stderr
    elif opt.logfile == 'stdout':
        logfile = sys.stdout
    else:
        logfile = opt.logfile

    run(
        arg_pdbout=opt.pdbout,
        arg_pdbin=pdbin,
        arg_nohyd=opt.nohyd,
        arg_dry=opt.dry,
        arg_strip_atom_mask=opt.strip_atom_mask,
        arg_mutate_string=opt.mutation_string,
        arg_prot=opt.prot,
        arg_amber_compatible_residues=opt.amber_compatible_residues,
        arg_constph=opt.constantph,
        arg_mostpop=opt.mostpop,
        arg_reduce=opt.reduce,
        arg_no_reduce_db=opt.no_reduce_db,
        arg_model=opt.model - 1,
        arg_keep_altlocs=opt.keep_altlocs,
        arg_add_missing_atoms=opt.add_missing_atoms,
        arg_logfile=logfile,
        arg_leap_template=opt.leap_template,
        arg_conect=not opt.no_conect,
        arg_noter=opt.noter)


if __name__ == '__main__':
    main()
